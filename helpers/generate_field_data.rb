#!/usr/bin/ruby

# collect all lvm reporting columns and format to our liking for inclusion in
# the library
#
# ruby generate_field_data.rb ~/iscsi_work/LVM2.2.02.36

require 'yaml'

LVM_COLUMNS = "/lib/report/columns.h"

CONVERSION_MAP = {
 # Only types we can really trust
 "uint32" => "Integer",
 "int32" => "Integer",
 # These were determined by reading the code, they invoke _(u)int32_disp right away
 "pvmdas" => "Integer",
 "vgmdas" => "Integer",
 "lvcount" => "Integer",
 "lvsegcount" => "Integer",
 "segstartpe" => "Integer",
 # listed to return STR?
 "lvkmaj" => "Integer",
 "lvkmin" => "Integer",
 "snpercent" => "Float",
 "copypercent" => "Float",
 # size32/64, these do unit formatting unless overridden on command line. We
 # typically want them in bytes so we can convert them to Integers safely
 "size32" => "Integer",
 "size64" => "Integer",
 # These types return size32/size64 as well
 "lvkreadahead" => "Integer",
 "pvsize" => "Integer",
 "devsize" => "Integer",
 "pvfree" => "Integer",
 "pvused" => "Integer",
 "pvmdafree" => "Integer",
 "vgsize" => "Integer",
 "vgfree" => "Integer",
 "vgmda_free" => "Integer",
 "chunksize" => "Integer",
 "segstart" => "Integer",
 "segsize" => "Integer",
 "vgmdafree" => "Integer",
 # Weird one, can be "auto" or size32
 "lvreadahead" => "String"
}

lvm_source = ARGV[0]

lvs = [] 
vgs = []
pvs = []
File.readlines(lvm_source + LVM_COLUMNS).each do |line|
  chunked = line.split(", ")

  app = chunked[0]
  general_type = chunked[2]
  specific_type = chunked[6] 
  field = chunked[7]
#  description = chunked[8]

  attribute = field
  attribute_type = nil

  if app.nil? || general_type.nil? || specific_type.nil? || field.nil?
    next
  end

  attribute.gsub!('"', '')

  if general_type == "NUM"
    attribute_type = CONVERSION_MAP[specific_type]
    if attribute_type.nil?
      puts "oops, missing hanlding of attribute '#{attribute}' which says its going to return a '#{specific_type}'"
      exit 1
    end
  else
    attribute_type = "String"
  end
 #XXX man page says we can skip the lv_ prefixes! and seg_!
  if app == "FIELD(LVS" || app == "FIELD(SEGS"
    lvs << { :option => attribute, :type_hint => attribute_type, :method => attribute.sub(%r{^lv_}, '') }
  elsif app == "FIELD(PVS" || app == "FIELD(PVSEGS"
    pvs << { :option => attribute, :type_hint => attribute_type, :method => attribute.sub(%r{^pv_}, '') }
  elsif app == "FIELD(VGS"
    vgs << { :option => attribute, :type_hint => attribute_type, :method => attribute.sub(%r{^vg_}, '') }
  end
end

lvs.sort! {|x,y| x[:option] <=> y[:option]}
pvs.sort! {|x,y| x[:option] <=> y[:option]} 
vgs.sort! {|x,y| x[:option] <=> y[:option]}

File.open("lvs.yaml", "w") do |f|
  f.write "# these are column to object attribute mappings \n"
  f.write "# generated by #{$0} based on \n"
  f.write "# #{lvm_source}/lib/report/columns.h\n"
  f.write(lvs.to_yaml)
end
puts "Wrote data to lvs.yaml"

File.open("pvs.yaml", "w") do |f|
  f.write "# these are column to object attribute mappings \n"
  f.write "# generated by #{$0} based on \n"
  f.write "# #{lvm_source}/lib/report/columns.h\n"
  f.write(pvs.to_yaml)
end
puts "Wrote data to pvs.yaml"

File.open("vgs.yaml", "w") do |f|
  f.write "# these are column to object attribute mappings \n"
  f.write "# generated by #{$0} based on \n"
  f.write "# #{lvm_source}/lib/report/columns.h\n"
  f.write(vgs.to_yaml)
end
puts "Wrote data to vgs.yaml"
